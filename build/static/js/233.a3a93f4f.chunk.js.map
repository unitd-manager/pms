{"version":3,"sources":["../../../src/Can.ts","../../../src/Condition.ts","../../../src/utils.ts","../../../src/builder.ts","../../../src/parsers/defaultInstructionParsers.ts","../../../src/parsers/ObjectQueryParser.ts","../../../src/interpreter.ts","../../../src/index.ts","../../../src/instructions.ts","../../../src/MongoQueryParser.ts","../../../src/interpreters.ts","../../../src/defaults.ts","../../../src/factory.ts","../../../src/translator.ts","../../../src/Rule.ts","../../../src/structures/LinkedItem.ts","../../../src/RuleIndex.ts","../../../src/PureAbility.ts","../../../src/matchers/conditions.ts","../../../src/matchers/field.ts","../../../src/Ability.ts","../../../src/AbilityBuilder.ts","../../../src/ForbiddenError.ts"],"names":["noop","renderChildren","Fragment","children","length","createElement","Children","only","Can","_isAllowed","_ability","n","_unsubscribeFromAbility","componentWillUnmount","_connectToAbility","ability","this","on","_this2","forceUpdate","_canRender","props","subject","of","a","an","can","not","I","do","field","render","passThrough","_renderChildren","elements","PureComponent","Condition","operator","value","Object","defineProperty","writable","addNote","note","_notes","push","DocumentCondition","CompoundCondition","conditions","Array","isArray","Error","_DocumentCondition","ITSELF","FieldCondition","NULL_CONDITION","hasOwnProperty","prototype","call","bind","isCompound","condition","optimizedCompoundCondition","flattenConditions","aggregatedResult","flatConditions","i","currentNode","identity","x","object","create","ignoreValue","objectKeysSkipIgnore","anyObject","keys","key","pushIfNonNullCondition","buildAnd","defaultInstructionParsers","compound","instruction","context","map","parse","query","name","document","ObjectQueryParser","instructions","options","_instructions","_fieldInstructionContext","_documentInstructionContext","_options","_objectKeys","operatorToConditionName","defaultOperatorName","mergeFinalConditions","reduce","all","_this","fieldContext","hasOperators","skipIgnore","constructor","prop","useIgnoreValue","documentContext","setParse","parseField","parentQuery","type","parseInstruction","validate","parseFieldOperators","op","getInterpreter","interpreters","interpret","defaultInterpreterName","ensureIsArray","ensureIsNonEmptyArray","ensureIs","$and","queries","$or","$nor","$not","RegExp","$elemMatch","$size","$in","$nin","$all","$mod","$exists","$gte","Date","$gt","$lt","$lte","$eq","$ne","$regex","rawValue","$options","$where","MongoQueryParser","_ObjectQueryParser","slice","and","allParsingInstructions","includes","items","compare","isArrayAndNotNumericField","Number","isNaN","getField","get","result","concat","testValueOrArray","test","node","some","v","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","getObjectField","String","indexOf","paths","split","b","createJsInterpreter","operators","rawOptions","getInterpreterName","numberOfArguments","interpreterName","defaultContext","params","createInterpreter","or","every","eq","ne","lte","lt","gt","gte","exists","item","mod","size","regex","within","nin","elemMatch","allInterpreters","in","toPrimitive","getTime","toJSON","comparePrimitives","createFactory","parser","forPrimitives","args","ast","translate","defaultParsers","wrapArray","TYPE_FIELD","isSubjectType","getSubjectClassName","modelName","getSubjectTypeName","detectSubjectType","copyArrayTo","dest","target","start","mergePrioritized","array","anotherArray","j","merged","priority","getOrDefault","defaultValue","set","Rule","rule","fields","fieldMatcher","conditionsMatcher","action","resolveAction","inverted","reason","undefined","_conditionsMatcher","_matchConditions","matchesConditions","matches","matchesField","_matchField","cloneLinkedItem","prev","next","defaultActionEntry","rules","defaultSubjectEntry","Map","analyze","index","_hasPerFieldRules","RuleIndex","_events","_ruleOptions","_anyAction","anyAction","_anySubjectType","anySubjectType","_detectSubjectType","_rules","_indexedRules","_buildIndexFor","update","event","_emit","rawRules","indexedRules","actions","subjects","k","subjectRules","possibleRulesFor","subjectType","actionRules","anyActionRules","has","rulesFor","filter","handler","linkedItem","tail","currentTail","delete","unlinkItem","payload","current","PureAbility","relevantRuleFor","cannot","defaultInstructions","defaultInterpreters","mongoQueryMatcher","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","string","quantifier","matcher","pattern","replace","escapeRegexp","fieldPatternMatcher","f","patterns","join","createPattern","Ability","_PureAbility","RuleBuilder","_rule","because","AbilityBuilder","AbilityType","_AbilityType","build","conditionsOrFields","builder","defineAbility","define","then","NativeError","message","ForbiddenError","captureStackTrace","setDefaultMessage","messageOrFn","_defaultErrorMessage","from","setMessage","throwUnlessCan","error","getDefaultErrorMessage"],"mappings":"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","file":"static/js/233.a3a93f4f.chunk.js","sourcesContent":["import { Children, ReactNodeArray, PureComponent, Fragment, createElement } from 'react';\nimport {\n  Unsubscribe,\n  AbilityTuple,\n  SubjectType,\n  AnyAbility,\n  Generics,\n  Abilities,\n  IfString,\n} from '@casl/ability';\n\nconst noop = () => {};\nconst renderChildren = Fragment\n  ? (children?: ReactNodeArray) => {\n    if (!children) {\n      return null;\n    }\n\n    return children.length > 1\n      ? createElement(Fragment, null, ...children)\n      : Children.only(children);\n  }\n  : Children.only;\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\ninterface ExtraProps {\n  not?: boolean\n  passThrough?: boolean\n}\n\ninterface CanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability: T\n}\n\ninterface BoundCanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability?: T\n}\n\nexport type CanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & CanExtraProps<T>;\nexport type BoundCanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & BoundCanExtraProps<T>;\n\nexport class Can<\n  T extends AnyAbility,\n  IsBound extends boolean = false\n> extends PureComponent<IsBound extends true ? BoundCanProps<T> : CanProps<T>> {\n  private _isAllowed: boolean = false;\n  private _ability: T | null = null;\n  private _unsubscribeFromAbility: Unsubscribe = noop;\n\n  componentWillUnmount() {\n    this._unsubscribeFromAbility();\n  }\n\n  private _connectToAbility(ability?: T) {\n    if (ability === this._ability) {\n      return;\n    }\n\n    this._unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this._unsubscribeFromAbility = ability.on('updated', () => this.forceUpdate());\n    }\n  }\n\n  get allowed() {\n    return this._isAllowed;\n  }\n\n  private _canRender(): boolean {\n    const props: any = this.props;\n    const subject = props.of || props.a || props.an || props.this || props.on;\n    const can = props.not ? 'cannot' : 'can';\n\n    return props.ability[can](props.I || props.do, subject, props.field);\n  }\n\n  render() {\n    this._connectToAbility(this.props.ability);\n    this._isAllowed = this._canRender();\n    return this.props.passThrough || this._isAllowed ? this._renderChildren() : null;\n  }\n\n  private _renderChildren() {\n    const { children, ability } = this.props;\n    const elements = typeof children === 'function'\n      ? children(this._isAllowed, ability)\n      : children;\n\n    return renderChildren(elements);\n  }\n}\n","export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n","import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n","import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n","import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object;\n    if (!object) return this._anySubjectType;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    const tail = this._events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    this._events.set(event, item);\n\n    return () => {\n      const currentTail = this._events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        this._events.delete(event);\n      } else if (item === currentTail) {\n        this._events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public } from './RuleIndex';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<Ability<any, MongoQuery>> {}\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends string\n    ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n      ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n      : AnyObject\n    : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AnyClass<T>;\n\n  constructor(AbilityType: AnyClass<T>) {\n    this._AbilityType = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U) {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(args[1]));\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n"],"sourceRoot":""}